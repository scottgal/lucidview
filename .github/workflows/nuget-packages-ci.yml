name: NuGet Packages CI

on:
  pull_request:
    paths:
      - Naiad/**
      - .github/workflows/nuget-packages-ci.yml
  push:
    branches:
      - main
      - develop
    paths:
      - Naiad/**
      - .github/workflows/nuget-packages-ci.yml
  workflow_dispatch:

env:
  DOTNET_VERSION: 10.0.x

jobs:
  detect-impacted-packages:
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.detect.outputs.has_changes }}
      matrix: ${{ steps.detect.outputs.matrix }}
      changed_files: ${{ steps.detect.outputs.changed_files }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect impacted packages
        id: detect
        shell: python
        env:
          EVENT_NAME: ${{ github.event_name }}
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          BEFORE_SHA: ${{ github.event.before }}
          HEAD_SHA: ${{ github.sha }}
        run: |
          import json
          import os
          import pathlib
          import subprocess
          import xml.etree.ElementTree as ET

          repo = pathlib.Path(".").resolve()

          package_projects = [
              "Naiad/src/Naiad/Naiad.csproj",
              "Naiad/src/Naiad.Blazor/Naiad.Blazor.csproj",
              "Naiad/src/Naiad.Meta.Mermaid/Naiad.Meta.Mermaid.csproj",
              "Naiad/src/Naiad.Meta.Complete/Naiad.Meta.Complete.csproj",
              "Naiad/src/Naiad.Skins.Cats/Naiad.Skins.Cats.csproj",
              "Naiad/src/Naiad.Skins.Showcase/Naiad.Skins.Showcase.csproj",
              "Naiad/src/Naiad.Surfaces.ImageSharp/Naiad.Surfaces.ImageSharp.csproj",
              "Naiad/src/Naiad.Surfaces.Skia/Naiad.Surfaces.Skia.csproj",
          ]

          package_projects = [repo / p for p in package_projects]

          def normalize(path: str) -> str:
              return path.replace("\\", "/").strip("/")

          event_name = os.environ.get("EVENT_NAME", "")
          if event_name == "pull_request":
              base_sha = os.environ.get("BASE_SHA", "").strip()
          elif event_name == "push":
              base_sha = os.environ.get("BEFORE_SHA", "").strip()
          else:
              base_sha = ""

          head_sha = os.environ.get("HEAD_SHA", "").strip()
          changed_files: list[str] = []

          if base_sha:
              if base_sha == "0000000000000000000000000000000000000000":
                  changed_files = [
                      normalize(p)
                      for p in subprocess.check_output(
                          ["git", "ls-files"], text=True
                      ).splitlines()
                      if p.strip()
                  ]
              else:
                  changed_files = [
                      normalize(p)
                      for p in subprocess.check_output(
                          ["git", "diff", "--name-only", f"{base_sha}..{head_sha}"],
                          text=True,
                      ).splitlines()
                      if p.strip()
                  ]
          else:
              changed_files = [
                  normalize(p)
                  for p in subprocess.check_output(
                      ["git", "ls-files"], text=True
                  ).splitlines()
                  if p.strip()
              ]

          def parse_package_id(project_path: pathlib.Path) -> str:
              try:
                  root = ET.parse(project_path).getroot()
              except ET.ParseError:
                  return project_path.stem
              for elem in root.iter():
                  if elem.tag.endswith("PackageId") and elem.text and elem.text.strip():
                      return elem.text.strip()
              return project_path.stem

          def project_references(project_path: pathlib.Path) -> set[pathlib.Path]:
              refs: set[pathlib.Path] = set()
              stack = [project_path.resolve()]
              visited: set[pathlib.Path] = set()
              while stack:
                  current = stack.pop()
                  if current in visited:
                      continue
                  visited.add(current)
                  try:
                      root = ET.parse(current).getroot()
                  except ET.ParseError:
                      continue
                  for elem in root.iter():
                      if not elem.tag.endswith("ProjectReference"):
                          continue
                      include = (elem.attrib.get("Include") or "").strip()
                      if not include:
                          continue
                      candidate = (current.parent / include).resolve()
                      if candidate.exists() and candidate not in refs:
                          refs.add(candidate)
                          stack.append(candidate)
              return refs

          def starts_with(path: str, prefix: str) -> bool:
              return path == prefix or path.startswith(prefix + "/")

          impacted = []
          for project in package_projects:
              if not project.exists():
                  continue
              package_id = parse_package_id(project)
              watch_prefixes = set()

              rel_project = normalize(str(project.relative_to(repo).as_posix()))
              project_dir = normalize(str(project.parent.relative_to(repo).as_posix()))
              watch_prefixes.add(project_dir)
              watch_prefixes.add(rel_project)

              refs = project_references(project)
              for ref in refs:
                  try:
                      rel_ref_dir = normalize(str(ref.parent.relative_to(repo).as_posix()))
                      rel_ref_file = normalize(str(ref.relative_to(repo).as_posix()))
                  except ValueError:
                      continue
                  watch_prefixes.add(rel_ref_dir)
                  watch_prefixes.add(rel_ref_file)

              if rel_project.startswith("Naiad/src/"):
                  watch_prefixes.add("Naiad/src/Directory.Build.props")
                  watch_prefixes.add("Naiad/src/Directory.Packages.props")
                  watch_prefixes.add("Naiad/src/global.json")

              project_changed = any(
                  any(starts_with(changed, prefix) for prefix in watch_prefixes)
                  for changed in changed_files
              )

              if project_changed:
                  impacted.append(
                      {
                          "project_path": rel_project,
                          "package_id": package_id,
                          "artifact_id": package_id.lower().replace(".", "-"),
                      }
                  )

          matrix = {"include": impacted}
          has_changes = "true" if impacted else "false"

          output = os.environ["GITHUB_OUTPUT"]
          with open(output, "a", encoding="utf-8") as fh:
              fh.write(f"has_changes={has_changes}\n")
              fh.write(f"matrix={json.dumps(matrix, separators=(',', ':'))}\n")
              fh.write("changed_files<<EOF\n")
              for file in changed_files:
                  fh.write(file + "\n")
              fh.write("EOF\n")

          print("Changed files:")
          for file in changed_files:
              print(f"- {file}")

          print("Impacted packages:")
          for item in impacted:
              print(f"- {item['package_id']} ({item['project_path']})")

  pack-impacted-packages:
    needs: detect-impacted-packages
    if: ${{ needs.detect-impacted-packages.outputs.has_changes == 'true' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: ${{ fromJson(needs.detect-impacted-packages.outputs.matrix) }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: Restore
        run: dotnet restore ${{ matrix.project_path }}

      - name: Build
        run: dotnet build ${{ matrix.project_path }} -c Release --no-restore -p:GeneratePackageOnBuild=false

      - name: Pack
        run: dotnet pack ${{ matrix.project_path }} -c Release --no-build -o ./nupkg -p:GeneratePackageOnBuild=false

      - name: Upload package artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nupkg-${{ matrix.artifact_id }}
          path: ./nupkg/*.nupkg

  no-packages-impacted:
    needs: detect-impacted-packages
    if: ${{ needs.detect-impacted-packages.outputs.has_changes != 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: No impacted packages
        run: echo "No NuGet packages were impacted by this change."
